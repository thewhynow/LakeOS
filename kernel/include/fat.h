#ifndef _FAT_H
#define _FAT_H

#include "../../libc/include/types.h"
#include "sal.h"

#ifdef _FAT_H_INTERNAL

typedef struct {
    /**
     * jump instruction to boot code.. 2 forms:
     *      0x EB ?? 90
     *      0x E9 ?? ??
     * forms an unconditional x86_64 jump instruction
     * to the rest of the boot code
     */
    uint8_t _jump_instruction[3];

    /**
     * simply a name field
     *  - some indication of the system that formatted the volume
     *  - typically "MSWIN4.1"
     *  - we will use "LAKEOS.0"
     */
    uint8_t  OEM_name[8];

    /**
     * count of bytes per sector
     *  - must be a power of 2 (512, 1024, 4096)
     *  - for maximum compat. use 512 sector-size disks
     */
    uint16_t bytes_per_sector;
    
    /**
     * number of sectors per cluster (allocation unit)
     *  - must be a power of 2 (2^(0 -> 7))
     *  * bytes_per_sector * sectors_per_cluster must NOT
     *    result in a cluster size > 32K (32768)
     */
    uint8_t  sectors_per_cluster; 

    /**
     * number of reserved sectors, starting from the first
     *  - on FAT12+16 volumes, should be 1
     *  - on FAT32, should be 32
     *  * CANNOT be 0!!
     */
    uint16_t reserved_sectors;

    /**
     * count of FAT structures on the volume
     *  * SHOULD ALWAYS BE 2
     *      -> to provide redundancy if a sector
     *         holding one FAT goes bad
     *  - may be set to 1 for mediums (such as flash)
     *    where such redundancy is irrelevant
     */
    uint8_t  num_fat;

    /**
     *  - on FAT12+16 volumes:
     *      - number of 32b directory entries in root directory
     *      - when multiplied by 32, should be an even multiple of
     *        bytes_per_sector
     *      - on FAT16, should be set to 512
     *   - on FAT32 volumes, set to 0
     */
    uint16_t num_root_entries;
    
    /**
     * old 16-bit count of total sectors on volume
     * 
     *  - on FAT12+16, stores the count
     *      * if the count is >= 0x10000, should be
     *        stored in newer field and this field
     *        should be 0
     *  - on FAT32, this field should be 0 and
     *    unused
     */
    uint16_t num_sectors;
    
    /**
     * 0xF8 is standard for non-removeable media
     * 0xF0 is standard for yes-removeable media
     * 
     *  * whatever byte is put here must also be put in the low byte
     *    of the FAT[0] entry
     */
    uint8_t  media;

    /**
     *  - on FAT12+16, used for sectors per FAT
     *  - on FAT32, must be 0
     */
    uint16_t sectors_per_fat;

    /**
     * sectors per track, used for int $0x13
     *  - only relevant for mediums that have geometry
     */
    uint16_t sectors_per_track;
    
    /**
     * number of heads, used ofr int $0x13
     *  - only relevant for mediums that have geometry
     *  * for 1.44MB floppies, use value 2
     */
    uint16_t heads_per_cylinder;

    /**
     * count of hidden sectors before the partition that contains this FAT volume
     *  - only relevant for media visible on int $0x13
     *  - should be 0 on media that are not paritioned
     *  - OS specific (ignore it XD)
     */
    uint32_t hidden_sectors;
    
    /**
     * new 32-bit count of total sectors on volume
     *  - for FAT12+16 must be non-zero if total sectors > 16-bit
     *  - for FAT32, must be non-zero
     */
    uint32_t long_sectors;

    /* at this point, the boot structure differs between FAT16+12 and FAT32 */
} __attribute__((__packed__)) t_BootSectorCommon;

typedef struct {
    /* common Boot Sector extension between FAT16+12+32 but at different offsets */

    /**
     * the drive number used by int $0x13
     *  - 0x00 for floppies, 0x80 for hard disks
     *  * actually OS-specific (?)
     */
    uint8_t drive_num;

    /**
     * field is reserved by Windows NT
     *  - always set this byte to 0
     */
    uint8_t _reserved_1;

    /**
     * extended boot signature
     *  - indicates following 3 fields are present
     *  - 0x29
     */
    uint8_t ext_boot_sig;

    /**
     * supports volume tracking on removeable media
     *  - allows drivers to detect wrong disk is inserted into drive
     *  - ID usually generated by combining curent date and time
     */
    uint32_t vol_serial_num;

    /**
     * matches 11-byte volume label recorded in root directory
     * 
     *  * make sure to update this value when the name of the 
     *    volume label file in root directory is changed
     *  * default name is:
     *      "NO NAME    "
     */
    uint8_t vol_label[11];

    /**
     * NOT used for file system determination
     *  - should be set for non-microsoft drivers
     *  - possible values include:
     *      "FAT 12  "
     *      "FAT 16  "
     *      "FAT 32  "
     */
    uint8_t file_sys_type[8];
} __attribute__((__packed__)) t_BootSectorCommonExt;

typedef struct {
    /* all fields defined here do NOT exist for FAT12+16 volumes */

    /**
     * number of sectors per FAT
     *  - BootSector.sectors_per_fat must be 0
     */
    uint32_t sectors_per_fat;

    /**
     * [0:3] -> 0-based number of active FAT (dependent on [7])
     * [4:6] -> reserved
     * [7]=0 -> FAT is mirrored at runtime into all other FATs
     *    =1 -> only one FAT is active, the one mentioned in [0:3]
     * [8:15]-> reserved
     */
    uint16_t flags_ext;

    /**
     * high-byte is major revision; low-byte is minor
     *  - supports ability to extend FAT32 in future
     *  - this driver supports 0:0
     *  * respect this field!
     */
    uint16_t version_number;

    /**
     * set to the first cluster of the root directory
     *  - usually 2, but not required
     */
    uint32_t root_cluster_num;

    /**
     * sector number of FSINFO structure in reserved area
     *  - usually 1
     */
    uint16_t fsinfo_sector_num;

    /**
     * sector number of boot record in reserved area
     *  - usually 6, any other value is NOT recommended
     */
    uint16_t boot_record_sector_num;

    /**
     * reserved for future expansion
     *  - should be set to 0
     */
    uint8_t _reserved_2[12];
} __attribute__((__packed__)) t_BootSector32Ext;

typedef struct {
    /**
     * should be equal to: 0x41615252
     * indicates this is a valid FSInfo sector
     */
    uint32_t lead_signature;

    /**
     * reserved for future expansion
     * should be initialized to 0 by formatters
     */
    uint8_t reserved_1[480];

    /**
     * should be equal to: 0x61417272
     * again, indicates this is a valid FSInfo sector
     */
    uint32_t middle_signature;

    /**
     * contains the last known free cluster count
     * if the value is 0xFFFFFFFF, needs to be computed
     *  - other values can be used, but are not correct
     *  - should be range checked within total clusters
     */
    uint32_t num_free_clusters;

    /**
     * hint for the FAT32 driver
     *  - indicates the cluster number at which to start
     *    looking for free clusters
     *  - typically marked as the last cluster allocated
     *  - if set to 0xFFFFFFFF, the driver should start
     *    looking from cluster 2
     */
    uint32_t last_free_cluster;

    /**
     * reserved for future expansion
     * should be initialized to 0 by formatters
     */
    uint8_t resrved_2[12];

    /**
     * should be equal to: 0xAA550000
     * again, indicates this is a valid FSInfo sector
     * - the last two bytes match the signature in sector0
     */
    uint32_t trail_signature;
} __attribute__((__packed__)) t_FAT32_FSInfo;

typedef enum {
    FAT_NULL,
    FAT_12,
    FAT_16,
    FAT_32,
} e_FAT;

typedef struct {
    t_BootSectorCommon    boot_sector;
    union {
        t_BootSectorCommonExt  old_ext;
        t_BootSector32Ext      fat32_ext;
    };
    t_BootSectorCommonExt      fat32_common_ext;
    
    e_FAT                 type;
    storage_device_t     *device;

    /**
     * marks the start of the data region
     *  defined by the clusters
     */
    uint32_t             data_region_start;

    /**
     * even though this field does exist, do not
     *  make the mistake assuming that this field 
     *  is actually used in offset calculations!
     * 
     * it would be considered good practice to set
     *  it, just in case...
     */
    size_t                partition_start;
} t_FATContext;

#define SECTORS_PER_FAT(context) (            \
    (context)->boot_sector.sectors_per_fat    \
    ? (context)->boot_sector.sectors_per_fat  \
    : (context)->fat32_ext.sectors_per_fat    \
)

/**
 * FAT Notes:
 *  - sector0[510] == 0x55 && sector0[511] == 0xAA
 * FAT Datastructure:
 *  - defines a singly-linked list of the clusters in a file
 *  - directory is just a file w/ a special attribute,
 *    contents are the directory entries
 *  - since the first 2 clusters are unused, they have special
 *    meanings within the FAT
 *    - FAT[0]:
 *      - contains the BPB_media byte value in low byte
 *      - rest is all 1s
 *    - FAT[1]:
 *      - EOC Mark
 *      - special but irrelevant flags on FAT16+32
 */

/**
 * these tables are used in FAT16+32 volumes to determine the
 * BPB.sectors_per_cluster value from the BPB.total_sectors value
 * 
 * assumes that the BPB.bytes_per_sector is 512
 * 
 * since FAT12 is only used for floppy disks, the values are constant
 * and a table is not needed. what exactly these values are is fucking
 * unkown to me, microsoft mentions them and never provides them...
 */

typedef struct {
    uint32_t total_sectors;
    uint8_t  sectors_per_cluster;
} t_TotalSectors_SectorsPerCluster;

/**
 * for this table to work, BPB.reserved_sectors = 1, BPB.num_fats = 2, BPB.root_entry_count = 512
 */
static const t_TotalSectors_SectorsPerCluster FAT16_NUM_SECTORS_TO_SECTORS_PER_CLUSTER[] = {
    {8400,       0},  /* disks under 4.1MB, invalid */
    {32680,      2},  /* disks up to 16 MB, 1k cluster */
    {262144,     4},  /* disks up to 128 MB, 2k cluster */
    {524288,     8},  /* disks up to 256 MB, 4k cluster */
    {1048576,    16}, /* disks up to 512 MB, 8k cluster */

    /* entries after this point are not used unless FAT16 is forced */
    
    {2097152,    32}, /* disks up to 1 GB, 16k cluster */
    {4194304,    64}, /* disks up to 2 GB, 32k cluster */
    {0xFFFFFFFF, 0}   /* any disk greater than 2GB, invalid */
};

static const t_TotalSectors_SectorsPerCluster FAT32_NUM_SECTORS_TO_SECTORS_PER_CLUSTER[] = {
    {66600,      0},  /* disks up to 32.5 MB, invalid */
    {532480,     1},  /* disks up to 260 MB, .5k cluster */
    {16777216,   8},  /* disks up to 8 GB, 4k cluster */
    {33554432,   16}, /* disks up to 16 GB, 8k cluster */
    {67108864,   32}, /* disks up to 32 GB, 16k cluster */
    {0xFFFFFFFF, 64}  /* disks greater than 32GB, 32k cluster */
};

/**
 * FAT Directory Structure
 * 
 * - on FAT12+16 media, the root directory is a fixed length and is in a fixed
 *   location on the media. 
 */


 /**
  * upper two bits of attrib byte are reserved and should be set to 0
  */
typedef enum {
    /* writes to the file should fail */
    ENTRY_ATTR_READ_ONLY = 0x01,
    /* file should not show up in normal directory listings */
    ENTRY_ATTR_HIDDEN    = 0x02,
    /* file is part of the operating system */
    ENTRY_ATTR_SYSTEM    = 0x04,
    /**
     * - there should only be one "file" that has this attribute
     * - name of said file is the volume label
     * - has to be in the root directory
     * - first_cluster_* should be 0
     */
    ENTRY_ATTR_VOLUME_ID = 0x08,
    /* file is a container for other files (no shit) */
    ENTRY_ATTR_DIRECTORY = 0x10,
    /* bit is set when the file is written, renamed, or created */
    ENTRY_ATTR_ARCHIVE   = 0x20,
    
    ENTRY_ATTR_LONG_NAME = ENTRY_ATTR_READ_ONLY | ENTRY_ATTR_HIDDEN | ENTRY_ATTR_SYSTEM | ENTRY_ATTR_VOLUME_ID,
    
    ENTRY_ATTR_MASK_LONG_NAME = ENTRY_ATTR_LONG_NAME | ENTRY_ATTR_DIRECTORY | ENTRY_ATTR_ARCHIVE
} e_DirEntryAttributes;

/**
 * when a directory is created:
 *  - set DirEntry.file_size to 0
 *  - allocate one cluster to the directory
 *  - assign appropriate cluster num fields
 *  - place EOC mark in the cluster entry
 *  - initialize cluster to 0
 *  - if directory is NOT root:
 *      - create two 32-byte dir entries
 *      - first entry has name set to "."
 *          set cluster nums to same
 *      - second entry has name set to ".."
 *          set cluster nums to above dir
 *          set 0 if directory is root directory
 */

/**
 * date & time formats:
 * date:
 *  [0:4]  -> day of month
 *  [5:8]  -> month of year [1 = jan, 12 = december]
 *  [9:15] -> count of years from 1980 [1980, 2107]
 *  - [1/1/1980, 12/31/2107]
 * time:
 *  [0:4]   -> 2 second count [0, 29 -> 0s, 58s]
 *  [5:10]  -> minutes [0, 59]
 *  [11:15] -> hours   [0, 23]
 *  - [12:00:00 AM, 11:59:58 PM]
 */

typedef struct {
    /**
     * short name
     * - if name[0] == 0xE5
     *   then the directory entry is free; no file or directory
     *   is in this entry
     * - if name[0] == 0x00
     *   then the directory entry is free, AND all the other entries
     *   in the directory are also free
     * - if name[0] == 0x05
     *   then the actual byte value for name[0] is 0xE5; Japanese
     *   character sets use this value for a specific character
     * 
     * - is broken into two parts:
     *   8-character file name
     *   3-character extension
     *   (implied '.' between name and extension)
     *   
     *  - lower-case characters are illegal
     *  - characters less than 0x20 (besides 0x05 special case) are illegal
     *  - 0x22, 0x2A, 0x2B, 0x2C, 0x2E, 0x2F, 0x3A, 0x3B, 0x3C, 0x3D, 
     *    0x3E, 0x3F, 0x5B, 0x5C, 0x5D, and 0x7C are illegal
     *  - name[0] != 0x20 (int)' '
     */
    uint8_t name[11];
    
    /* refer to e_FAT32_DirEntryAttribMasks for bit definitions */
    uint8_t attributes;
    
    /* reserved, set to 0 on file creation */
    uint8_t reserved;
    
    /**
     * stamps the tenth second at which a file was created
     * since the creation_time field has 2-second precision,
     * the value range for this field is 0-199 inclusive
     */
    uint8_t  creation_tenths;
    uint16_t creation_time;
    uint16_t creation_date;

    /* last date of a read or write operation */
    uint16_t last_access_date;

    /**
     * high word of the directories first cluster number
     * always 0 for FAT12+16
     */
    uint16_t first_cluster_high;

    uint16_t last_write_time;
    uint16_t last_write_date;

    /* low word of the directories first cluster number */
    uint16_t first_cluster_low;

    /* the size of the file, in BYTES */
    uint32_t file_size;
} __attribute__((__packed__)) t_ShortDirEntry;

typedef struct {
    /**
     * the order of this entry in a sequence of
     * long dir entries.
     * 
     * if masked with 0x40, this entry is the last
     * in a sequence of long dir entries. 
     * 
     * all valid sets of long dir entries must 
     * begin with this mask and then decrease
     * towards 1, then the short dir entry
     */
    uint8_t order;

    /**
     * characters 1-5 of the long name component
     *  in this entry.
     */
    uint16_t long_name_1[5];

    /**
     * must be FAT32_DIR_ATTR_LONG_NAME
     */
    uint8_t attribute;

    /**
     * if zero, this entry is part of a long name 
     * 
     * other values are reserved and should be ignored
     */
    uint8_t type;

    /**
     * checksum of the short name at the end of the
     *  LDIR entry chain
     * 
     * refer to
     *  uint8_t LDIR_entry_checksum(const uint8_t *short_name)
     */
    uint8_t checksum;

    /**
     * characters 6-11 of the long name component
     *  in this entry
     */
    uint16_t long_name_2[6];

    /**
     * set to ZERO
     * irrelevant, but must be set for compatibility
     */
    uint16_t first_cluster;

    /**
     * characters 12-13 of the long name component
     *  in this entry
     */
    uint16_t long_name_3[2];
} __attribute__((__packed__)) t_LongDirEntry;

typedef enum {
    DIR_ENTRY_INVALID,
    DIR_ENTRY_LONG_NAME,
    DIR_ENTRY_FILE,
    DIR_ENTRY_DIRECTORY,
    DIR_ENTRY_VOL_LABEL,
} e_LongDirEntryType;

void FAT_context_init(t_FATContext *context);
void FAT_test(t_FATContext *context);

void FAT_create(t_FATContext *ctx, const char *_path, uint32_t attribs);

uint32_t FAT_absolute_offset(t_FATContext *ctx, uint32_t cluster, size_t offset, uint32_t *clus_fail);

uint32_t FAT_dir_entry(t_FATContext *ctx, uint32_t cluster, uint32_t entry_num, void *out_entry);

size_t FAT_clus_to_off(t_FATContext *ctx, uint32_t cluster);

uint32_t FAT_find_file(t_FATContext *ctx, uint32_t cluster, const char *name);

uint32_t FAT_file_cluster(t_FATContext *ctx, const char *_path);

/**
 * returns true if the given cluster
 *  is within the root directory
 * on FAT12/16, clusters 0 and 1 are
 *  treated as root directory clusters
 */
bool FAT_is_root(t_FATContext *ctx, uint32_t cluster);

/**
 * finds a free entry in the directory
 *  starting at cluster and writes
 *  entry into it
 */
void FAT_write_entry(t_FATContext *ctx, uint32_t cluster, void *entry);

void FAT_conv_fname(const char *name, char *out);
#endif



#endif
